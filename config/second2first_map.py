# Generated by GPT-5, will need tuning and further review.

from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
import json
from typing import Dict, List, Tuple, Any

TEST = False  # Set to True to run basic test from main

CONFIG_DIR = Path(__file__).resolve().parent

# ---------- Load JSONs ----------
def _load_json(name: str) -> dict:
    with open(CONFIG_DIR / name, "r") as f:
        return json.load(f)

FIRST = _load_json("first_order_motion_prims.json")["primitives"]
SECOND = _load_json("second_order_actions.json")["actions"]
CTX = _load_json("context_defaults.json")

DT = CTX["timing"]["control_dt_s"]
MIN_PRIM_DUR = CTX["timing"]["primitive_min_duration_s"]

# ---------- Helper ----------
@dataclass(frozen=True)
class PrimStep:
    name: str
    duration_s: float

def _clamp_duration(t: float) -> float:
    return max(MIN_PRIM_DUR, float(t))

# ---------- Mapping (actions -> primitive sequences) ----------

def plan_sequence(action: str, obs: Dict[str, Any]) -> List[PrimStep]:
    """
    Return a short sequence of first-order primitives realizing the requested action.
    `obs` contains the observations named in second_order_actions.json for that action.
    """
    if action not in SECOND:
        raise ValueError(f"Unknown action: {action}")

    # Local aliases
    dist = CTX["distances_m"]
    speed = CTX["speed_tiers"]
    cross = CTX["crossing"]
    weave = CTX["weave"]
    bias = CTX["bias"]

    seq: List[PrimStep] = []

    if action == "FOLLOW_FLOW":
        d = float(obs.get("distance_ahead_m", 3.0))
        v_h = float(obs.get("ahead_speed_mps", 0.6))
        target = dist["normal_following_distance_m"]

        # choose speed tier by gap
        if d < 0.8 * target:
            tier = "FORWARD_SLOW"
        elif d < 1.1 * target:
            tier = "FORWARD_MED"
        else:
            tier = "FORWARD_FAST"

        # duration: go for 1â€“2 seconds depending on human speed
        dur = 1.0 if v_h < 0.6 else 2.0
        seq.append(PrimStep(tier, _clamp_duration(dur)))
        return seq

    if action == "YIELD_TO_HUMAN":
        clearance = float(obs.get("min_clearance_m", 0.0))
        if clearance < dist["yield_clearance_threshold_m"]:
            seq.append(PrimStep("STOP", _clamp_duration(1.0)))
        else:
            seq.append(PrimStep("FORWARD_SLOW", _clamp_duration(1.0)))
        return seq

    if action == "BYPASS_GROUP_LEFT":
        left_clear = float(obs.get("left_clearance_m", 0.0))
        if left_clear < dist["bypass_clearance_threshold_m"]:
            return [PrimStep("STOP", _clamp_duration(1.0))]
        # small forward + left strafe to arc around
        return [
            PrimStep("STRAFE_LEFT", _clamp_duration(0.6)),
            PrimStep("FORWARD_MED", _clamp_duration(1.2))
        ]

    if action == "BYPASS_GROUP_RIGHT":
        right_clear = float(obs.get("right_clearance_m", 0.0))
        if right_clear < dist["bypass_clearance_threshold_m"]:
            return [PrimStep("STOP", _clamp_duration(1.0))]
        return [
            PrimStep("STRAFE_RIGHT", _clamp_duration(0.6)),
            PrimStep("FORWARD_MED", _clamp_duration(1.2))
        ]

    if action == "KEEP_RIGHT_AGAINST_TRAFFIC":
        # Nudge right and proceed
        return [
            PrimStep("STRAFE_RIGHT", _clamp_duration(bias["lane_bias_right"])),
            PrimStep("FORWARD_MED", _clamp_duration(1.0))
        ]

    if action == "MERGE_WITH_TRAFFIC":
        gap = float(obs.get("gap_size_m", 0.0))
        if gap < dist["merge_gap_threshold_m"]:
            return [PrimStep("STOP", _clamp_duration(0.5))]
        heading_err = float(obs.get("merge_heading_error_rad", 0.0))
        steer = "TURN_LEFT" if heading_err > 0.0 else "TURN_RIGHT"
        return [
            PrimStep(steer, _clamp_duration(min(abs(heading_err), 0.5))),
            PrimStep("FORWARD_MED", _clamp_duration(1.2))
        ]

    if action == "WAIT_FOR_CLEAR":
        ahead = float(obs.get("path_clearance_ahead_m", 0.0))
        return [PrimStep("STOP", _clamp_duration(1.0))] if ahead < dist["path_clear_threshold_m"] \
               else [PrimStep("FORWARD_MED", _clamp_duration(1.0))]

    if action == "CROSS_AT_CROSSWALK":
        gap_t = float(obs.get("gap_time_sec", 0.0))
        if gap_t < cross["crosswalk_gap_threshold_sec"]:
            return [PrimStep("STOP", _clamp_duration(0.5))]
        head_err = float(obs.get("crosswalk_heading_error_rad", 0.0))
        if abs(head_err) > cross["crosswalk_heading_allowance_rad"]:
            steer = "TURN_LEFT" if head_err > 0 else "TURN_RIGHT"
            seq.append(PrimStep(steer, _clamp_duration(min(abs(head_err), 0.4))))
        seq.append(PrimStep("FORWARD_MED", _clamp_duration(1.5)))
        return seq

    if action == "WEAVE_THROUGH_CROWD":
        # alternate small lateral steps favoring the side with more clearance
        lc = float(obs.get("left_clearance_m", 0.0))
        rc = float(obs.get("right_clearance_m", 0.0))
        minc = CTX["distances_m"]["crowd_min_clearance_m"]
        if max(lc, rc) < minc:
            return [PrimStep("STOP", _clamp_duration(0.5))]
        prefer_left = lc >= rc
        weave_dur = _clamp_duration(weave["weave_step_duration_s"])
        return [
            PrimStep("STRAFE_LEFT" if prefer_left else "STRAFE_RIGHT", weave_dur),
            PrimStep("FORWARD_SLOW", weave_dur),
            PrimStep("STRAFE_RIGHT" if prefer_left else "STRAFE_LEFT", weave_dur),
            PrimStep("FORWARD_SLOW", weave_dur)
        ]

    if action == "PROCEED_SIDEWALK":
        tier = CTX["speed_tiers"]["cruise_speed_tier"]
        return [PrimStep(tier, _clamp_duration(1.0))]

    # Fallback
    return [PrimStep("STOP", _clamp_duration(0.5))]

# ---------- Convenience: expand to tuples for your sim loop ----------
def plan_sequence_tuples(action: str, obs: Dict[str, Any]) -> List[Tuple[str, float]]:
    return [(s.name, s.duration_s) for s in plan_sequence(action, obs)]


if __name__ == "__main__":
    if TEST:
        tests = [
            ("FOLLOW_FLOW", {"distance_ahead_m": 1.2, "ahead_speed_mps": 0.6}),
            ("YIELD_TO_HUMAN", {"min_clearance_m": 1.0}),
            ("BYPASS_GROUP_LEFT", {"left_clearance_m": 2.0, "group_width_m": 1.5}),
            ("CROSS_AT_CROSSWALK", {"gap_time_sec": 3.0, "crosswalk_heading_error_rad": 0.3}),
            ("WEAVE_THROUGH_CROWD", {"left_clearance_m": 1.2, "right_clearance_m": 0.9})
        ]
        for name, obs in tests:
            print(name, "->", plan_sequence_tuples(name, obs))
